<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>21年4月第2篇周志 | Seeker</title><meta name="author" content="Messier,914287707@qq.com"><meta name="copyright" content="Messier"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="安利warhammer 40k">
<meta property="og:type" content="article">
<meta property="og:title" content="21年4月第2篇周志">
<meta property="og:url" content="http://bithoxer.github.io/2021/04/11/21%E5%B9%B44%E6%9C%88%E7%AC%AC2%E7%AF%87%E5%91%A8%E5%BF%97/index.html">
<meta property="og:site_name" content="Seeker">
<meta property="og:description" content="安利warhammer 40k">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/bithoxer/imagestor/main/20210411235929.jpg">
<meta property="article:published_time" content="2021-04-11T15:35:00.000Z">
<meta property="article:modified_time" content="2021-04-11T16:00:15.204Z">
<meta property="article:author" content="Messier">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/bithoxer/imagestor/main/20210411235929.jpg"><link rel="shortcut icon" href="/img/Hermetic_Society.png"><link rel="canonical" href="http://bithoxer.github.io/2021/04/11/21%E5%B9%B44%E6%9C%88%E7%AC%AC2%E7%AF%87%E5%91%A8%E5%BF%97/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//zz.bdstatic.com"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}

// https://stackoverflow.com/questions/16839698/jquery-getscript-alternative-in-native-javascript
const getScript = url => new Promise((resolve, reject) => {
  const script = document.createElement('script')
  script.src = url
  script.async = true
  script.onerror = reject
  script.onload = script.onreadystatechange = function() {
    const loadState = this.readyState
    if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
    script.onload = script.onreadystatechange = null
    resolve()
  }
  document.head.appendChild(script)
})</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-04-12 00:00:15'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><meta name="generator" content="Hexo 5.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="Seeker" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/Lion_El'Jonson.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://raw.githubusercontent.com/bithoxer/imagestor/main/20210411235929.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Seeker</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">21年4月第2篇周志</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-04-11T15:35:00.000Z" title="发表于 2021-04-11 23:35:00">2021-04-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-04-11T16:00:15.204Z" title="更新于 2021-04-12 00:00:15">2021-04-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%91%A8%E5%BF%97/">周志</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>33分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>warhammer 40k安利：从CG短片“Astartes”说起</p>
<p>这是一篇有关warhammer 40k的软文，旨在普及++<span style="color:LightSteelBlue">( 宣传? )</span>++锤学。</p>
<p>首先安利一部CG同人短片…这部CG主要讲了一个由五只Astarte组成的kill team，怎样花式暴打凡人叛军，然后被牛鬼蛇神锤爆的故事（凡人叛军：我太难了）。</p>
<p>视频链接：</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/av327541867/">B站</a></p>
<p>看上去作者Syama Pedersen是一个新西兰人，有多年CG建模与动画制作的从业经验。据闻其独自一人创作这部短片，足足花了两年的时间……慢工出细活（歪个楼，话说作为纯靠兴趣的同人创作，这进度也不慢…），构图、布景、分镜、layout，行云流水，动作感真的很棒…可以看出尽管由于独木难支，作者舍弃了一些场景效果以控制项目成本（背景偏暗，人眼对暗处的亮度变化不敏感，这样就不用做细节了，嗯…所以背景细节略可惜？另外铠甲太过干净，这是为了节省建模&amp;渲染的时间和经济成本，比如更秃的小脑瓜&amp;更好更大的GPU），但无人否认Astates是一部杰出的同人创作，而且恐怕是目前最好的展现Astarte本质的动画。</p>
<p>感谢国内勤劳的搬运工…根据咱的调查，作者习惯将预告放在照片墙上，之后把视频链接发布到patron，视频本体则托管于Youtube。为了翻越叹息之墙(GFW)，请自备ladder…在instagram上的预告发布得最勤快，patron上有赞助链接…贝宝即可…</p>
<p><a target="_blank" rel="noopener" href="https://www.instagram.com/astartesfilm/">instagram</a></p>
<p><a target="_blank" rel="noopener" href="https://www.patreon.com/m/syamapedersen">patron</a></p>
<p><ins>如果感觉CG有点好玩，并且想了解warhammer 40k, 请接着往下看</ins></p>
<p><img src="https://img2.baidu.com/it/u=1473654623,3294545866&amp;fm=26&amp;fmt=auto&amp;gp=0.jpg" alt="img"></p>
<ol>
<li>
<p>CG中出现的Astarte是什么东东？</p>
<p>他们是warhammer 40000里的一群勤劳勇敢又可爱的工具人，哪里需要哪里搬。</p>
<p><a target="_blank" rel="noopener" href="https://warhammer40k.fandom.com/wiki/Space_Marines">Space marine(astarte的别称)</a></p>
<p>啊，刚才才注意到1d4chan上服务器502呢，据闻是被hack了，等两天再去看看。</p>
<p>以下网址在4月11号return 502，过几天没准就好了。</p>
<p><a target="_blank" rel="noopener" href="https://1d4chan.org/wiki/Space_Marines">1d4chan</a></p>
</li>
<li>
<p>warhammer 40000是什么？</p>
<p>有的问题是这样的，提出它只需要4秒钟，回答它却需要4个小时，正所谓bigger than bigger的问题。</p>
<p>自从托尔金的《精灵宝钻》首度构筑起奇幻体系的范式以来，有很多作者在此基础上进行了修改与再创作，最终形成了具有完整独立体系的IP。战锤40k就是大概上世纪70年代几个英美的年轻人在伦敦的地下室里，以这种方式创造的，他们以此创建了Game Workshop公司, 简称GW。</p>
<p>其中的40000表示故事大概发生在40个千年之后。让我们打个比方，最早的战锤40k可以理解成一个由太空歌剧组成的可爱婴儿，但不幸（或者万幸）的是，随着几十年来GW凶残的世界观构造师们（主要是Black Library，简称BL，的写手们）将这个婴儿摁在充斥着各种深黑残要素的泡澡水中，最后把婴儿倒掉，剩下的洗澡水基本就是现在我们看到的Warhammer 40000。</p>
</li>
<li>
<p>整体而言，我认为warhammer40k的世界观，是当前所有包含未来、奇幻、太空元素的世界观中最为暗黑的。无论是星战，光晕（Halo），阿西莫夫的基地，星际还是乱七八糟的其他，在grim-dark上皆难以望其项背…</p>
<p>较之物质条件的倒退，精神、伦理的退化更易动人心弦，战锤40k正是一部悲观主义视角下的太空人类帝国的衰亡史，人类一退再退，且终将一切尽失。（尽管GW为了强行给老大帝国续命，各种口胡、吃书、曲线救国…）</p>
</li>
<li>
<p>哪些人适合warhammer40k呢？它可能的确小众了些，毕竟相对于研究40000年的未来的历史，好像拿着光剑砍砍砍同时找女票复刻遗传物质更加简单明了。但是，我是说但是，如果您觉得人类有文字记录的几千年的历史不大够学习，那么入坑40k绝对是给自己找点事干的好方式。</p>
<p>另外，由于您很难找到比这个世界观下的普通人更惨的群体。这样即便是发生了诸如脚指头踢到了凳子腿的事故，您也能有足够的乐观心态，毕竟，跟战锤40k里生活是折磨，死亡方得安息的普通人比起来，这算得了什么呢？</p>
<p>最后，如果您天然地对穿着铠甲，抡着砍砍，端着哒咔，领着小子们车来车去感兴趣。那么战锤40k适合您，毕竟——其引文便是：In the grim darkness of far future, there is only war!</p>
</li>
</ol>
<p>还是喜欢写长一点的文字，归档记录，顺带整理一下心情，短文不适合咱。</p>
<h1 id="遥感企业"><a class="markdownIt-Anchor" href="#遥感企业"></a> 遥感企业</h1>
<p>2020年1月20日，ICEYE公司发布了用于检测没有通过AIS应答器的海上船只的图像。ICEYE将其3个合成孔径雷达卫星群的观测数据与其他数据源结合起来，为客户提供未通过AIS应答器的船只雷达卫星图像，包括船只位置和航向的识别。这项技术旨在帮助政府机构，非政府组织和商业客户遏制毒品和人口贩运、寻找非法渔船并执行禁止非法转运货物的规定。</p>
<p>2020年3月9日，ICEYE在YouTube上发布的有关ICEYE合成孔径雷达（SAR）视频的演示视频显示，SAR图像由单个卫星凝视模式生成，凝视时间为20秒或更长时间，经过数据处理之后，ICEYE将数据拆分为多个帧，以视频流的形式显示目标位置的移动变化。场景中运动目标的检测，对于检测目标的活动情况具有重大的意义，ICEYE公司所提供的SAR视频图像可用于跟踪卡车、火车、轮船甚至飞机所去某个地点的运动情况。</p>
<p><img src="https://mmbiz.qpic.cn/sz_mmbiz_jpg/RrO0NiaGGScibuvxZOcLPCgLv8kZ9o0mjEs7BPzGSic8wE5qJjnMHv3IWRicR9tLayU9CUR5EicR4aWuAPS8SCoUrUg/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<p>犹他州宾厄姆峡谷露天铜矿和卡车的的活动</p>
<p>在ICEYE发布的SAR视频中，演示了韩国釜山港船只的移动、英国希思罗机场飞机的运动、拉斯维加斯的城市生活、在犹他州宾厄姆峡谷矿的采矿活动、以及东京新宿附近的城市生活。ICEYE通过将每个区域的大约20秒图像分成10个数据帧来创建演示SAR视频图像，在提供SAR视频图像的同时，ICEYE-SAR提供的图像分辨率高达1米。</p>
<p>在商业航天遥感领域，ICEYE公司是第一个在轨道上实现并展示视频SAR能力的公司。ICEYE计划在2020年将星座的规模扩大一倍以上，以便能够更快地寻求特定目标图像。</p>
<p>2020年9月22日，ICEYE宣布在C轮融资中筹集了8,700万美元，使这家芬兰创业公司的总投资达到了1.52亿美元。自2014年在芬兰成立公司以来，Iceye已在波兰、英国和美国旧金山湾区设立了办事处。</p>
<p>随着商业航天的兴起，世界各地的公司都在筹集资金制造卫星以建设更多的SAR星座，包括位于旧金山的Capella Space、加利福尼亚州圣塔芭芭拉的Umbra实验室、东京Synspective、以及刚进行了2500万美元种子融资的PredaSAR公司。国内“智星空间”科技公司也计划在近年发射X频段商业合成孔径雷达卫星，开始建设至少由12颗SAR卫星组成的星座，实现对全球任意地点小时级的按需观测重放以及毫米级的形变检测。</p>
<p>matlab colormap函数做伪彩色，还可以用grayslice自定义颜色分层</p>
<h1 id="指针"><a class="markdownIt-Anchor" href="#指针"></a> 指针</h1>
<h2 id="c语言指针-从底层原理到花式技巧用图文和代码帮你讲解透彻"><a class="markdownIt-Anchor" href="#c语言指针-从底层原理到花式技巧用图文和代码帮你讲解透彻"></a> C语言指针-从底层原理到花式技巧，用图文和代码帮你讲解透彻</h2>
<ul>
<li>一、前言</li>
<li>二、变量与指针的本质</li>
<li>三、指针的几个相关概念</li>
<li>四、指向不同数据类型的指针</li>
<li>五、总结</li>
</ul>
<h2 id="一-前言"><a class="markdownIt-Anchor" href="#一-前言"></a> <strong>一、前言</strong></h2>
<p>如果问C语言中最重要、威力最大的概念是什么，答案必将是指针！威力大，意味着使用方便、高效，同时也意味着语法复杂、容易出错。指针用的好，可以极大的提高代码执行效率、节约系统资源；如果用的不好，程序中将会充满陷阱、漏洞。</p>
<p>这篇文章，我们就来聊聊指针。从最底层的内存存储空间开始，一直到应用层的各种指针使用技巧，循序渐进、抽丝剥茧，以最直白的语言进行讲解，让你一次看过瘾。</p>
<p>说明：为了方便讲解和理解，文中配图的内存空间的地址是随便写的，在实际计算机中是要遵循地址对齐方式的。</p>
<h2 id="二-变量与指针的本质"><a class="markdownIt-Anchor" href="#二-变量与指针的本质"></a> <strong>二、变量与指针的本质</strong></h2>
<h4 id="1-内存地址"><a class="markdownIt-Anchor" href="#1-内存地址"></a> 1. 内存地址</h4>
<p>我们编写一个程序源文件之后，编译得到的二进制可执行文件存放在电脑的硬盘上，此时它是一个静态的文件，一般称之为程序。</p>
<p>当这个程序被启动的时候，操作系统将会做下面几件事情：</p>
<blockquote>
<ol>
<li>把程序的内容(代码段、数据段)从硬盘复制到内存中；</li>
<li>创建一个数据结构PCB(进程控制块)，来描述这个程序的各种信息(例如：使用的资源，打开的文件描述符…);</li>
<li>在代码段中定位到入口函数的地址，让CPU从这个地址开始执行。</li>
</ol>
</blockquote>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
<p>当程序开始被执行时，就变成一个动态的状态，一般称之为进程。</p>
<blockquote>
<p>内存分为：物理内存和虚拟内存。操作系统对物理内存进行管理、包装，我们开发者面对的是操作系统提供的虚拟内存。<br>
这2个概念不妨碍文章的理解，因此就统一称之为内存。</p>
</blockquote>
<p>在我们的程序中，通过一个变量名来定义变量、使用变量。变量本身是一个确确实实存在的东西，变量名是一个抽象的概念，用来代表这个变量。就比如：我是一个实实在在的人，是客观存在与这个地球上的，道哥是我给自己起的一个名字，这个名字是任意取得，只要自己觉得好听就行，如果我愿意还可以起名叫：鸟哥、龙哥等等。</p>
<p>那么，我们定义一个变量之后，这个变量放在哪里呢？那就是内存的数据区。内存是一个很大的存储区域，被操作系统划分为一个一个的小空间，操作系统通过地址来管理内存。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/WC13ibsIvG3Z1bQiaSzo5N6GgZ7jYQ7V5opqxjG0ubcasfGa29ZXY7bccLYurFuxibMoNGibKDhDzM6SYPuoj1HWgw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<p>内存中的最小存储单位是字节(8个bit)，一个内存的完整空间就是由这一个一个的字节连续组成的。在上图中，每一个小格子代表一个字节，但是好像大家在书籍中没有这么来画内存模型的，更常见的是下面这样的画法：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/WC13ibsIvG3Z1bQiaSzo5N6GgZ7jYQ7V5oshXkfq8zXIicQIEdyNs6b5iaHeb3GefHGnSOo9mb80LKWsbdhuq5Vf7Q/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<p>也就是把连续的4个字节的空间画在一起，这样就便于表述和理解，特别是深入到代码对齐相关知识时更容易理解。(我认为根本原因应该是：大家都这么画，已经看顺眼了~~)</p>
<h4 id="2-32位与64位系统"><a class="markdownIt-Anchor" href="#2-32位与64位系统"></a> 2. 32位与64位系统</h4>
<p>我们平时所说的计算机是32位、64位，指的是计算机的CPU中寄存器的最大存储长度，如果寄存器中最大存储32bit的数据，就称之为32位系统。</p>
<p>在计算机中，数据一般都是在硬盘、内存和寄存器之间进行来回存取。CPU通过3种总线把各组成部分联系在一起：地址总线、数据总线和控制总线。地址总线的宽度决定了CPU的寻址能力，也就是CPU能达到的最大地址范围。</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
<p>刚才说了，内存是通过地址来管理的，那么CPU想从内存中的某个地址空间上存取一个数据，那么CPU就需要在地址总线上输出这个存储单元的地址。假如地址总线的宽度是8位，能表示的最大地址空间就是256个字节，能找到内存中最大的存储单元是255这个格子(从0开始)。即使内存条的实际空间是2G字节，CPU也没法使用后面的内存地址空间。如果地址总线的宽度是32位，那么能表示的最大地址就是2的32次方，也就是4G字节的空间。</p>
<p><em>【注意】</em>：这里只是描述地址总线的概念，实际的计算机中地址计算方式要复杂的多，比如：虚拟内存中采用分段、分页、偏移量来定位实际的物理内存，在分页中还有大页、小页之分，感兴趣的同学可以自己查一下相关资料。</p>
<h4 id="3-变量"><a class="markdownIt-Anchor" href="#3-变量"></a> 3. 变量</h4>
<p>我们在C程序中使用变量来“代表”一个数据，使用函数名来“代表”一个函数，变量名和函数名是程序员使用的助记符。变量和函数最终是要放到内存中才能被CPU使用的，而内存中所有的信息(代码和数据)都是以二进制的形式来存储的，计算机根据就不会从格式上来区分哪些是代码、哪些是数据。CPU在访问内存的时候需要的是地址，而不是变量名、函数名。</p>
<p><strong>问题来了</strong>：在程序代码中使用变量名来指代变量，而变量在内存中是根据地址来存放的，这二者之间如何映射(关联)起来的？</p>
<p>答案是：编译器！编译器在编译文本格式的C程序文件时，会根据目标运行平台(就是编译出的二进制程序运行在哪里？是x86平台的电脑？还是ARM平台的开发板？)来安排程序中的各种地址，例如：加载到内存中的地址、代码段的入口地址等等，同时编译器也会把程序中的所有变量名，转成该变量在内存中的存储地址。</p>
<p>变量有2个重要属性：变量的类型和变量的值。</p>
<p>示例：代码中定义了一个变量</p>
<pre class="highlight"><code class="">int a = 20;
</code></pre>
<p>类型是int型，值是20。这个变量在内存中的存储模型为：</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
<p>我们在代码中使用变量名a，在程序执行的时候就表示使用0x11223344地址所对应的那个存储单元中的数据。因此，可以理解为变量名a就等价于这个地址0x11223344。换句话说，如果我们可以提前知道编译器把变量a安排在地址0x11223344这个单元格中，我们就可以在程序中直接用这个地址值来操作这个变量。</p>
<p>在上图中，变量a的值为20，在内存中占据了4个格子的空间，也就是4个字节。为什么是4个字节呢？在C标准中并没有规定每种数据类型的变量一定要占用几个字节，这是与具体的机器、编译器有关。</p>
<p>比如：32位的编译器中：</p>
<blockquote>
<p>char: 1个字节；<br>
short int: 2个字节；<br>
int: 4个字节；<br>
long: 4个字节。</p>
</blockquote>
<p>比如：64位的编译器中：</p>
<blockquote>
<p>char: 1个字节；<br>
short int: 2个字节；<br>
int: 4个字节；<br>
long: 8个字节。</p>
</blockquote>
<p>为了方便描述，下面都以32位为例，也就是int型变量在内存中占据4个字节。</p>
<p>另外，0x11223344，0x11223345，0x11223346，0x11223347这连续的、从低地址到高地址的4个字节用来存储变量a的数值20。在图示中，使用十六进制来表示，十进制数值20转成16进制就是：0x00000014，所以从开始地址依次存放0x00、0x00、0x00、0x14这4个字节(存储顺序涉及到大小端的问题，不影响文本理解)。</p>
<p>根据这个图示，如果在程序中想知道变量a存储在内存中的什么位置，可以使用取地址操作符&amp;，如下：</p>
<pre class="highlight"><code class="">printf("&amp;a = 0x%x \n", &amp;a);
</code></pre>
<p>这句话将会打印出：<code>&amp;a = 0x11223344</code>。</p>
<p>考虑一下，在32位系统中：指针变量占用几个字节？</p>
<h4 id="4-指针变量"><a class="markdownIt-Anchor" href="#4-指针变量"></a> 4. 指针变量</h4>
<p>指针变量可以分2个层次来理解：</p>
<blockquote>
<ol>
<li>指针变量首先是一个变量，所以它拥有变量的所有属性：类型和值。它的类型就是指针，它的值是其他变量的地址。 既然是一个变量，那么在内存中就需要为这个变量分配一个存储空间。在这个存储空间中，存放着其他变量的地址。</li>
<li>指针变量所指向的数据类型，这是在定义指针变量的时候就确定的。例如：int *p; 意味着指针指向的是一个int型的数据。</li>
</ol>
</blockquote>
<p>首先回答一下刚才那个问题，在32位系统中，一个指针变量在内存中占据4个字节的空间。因为CPU对内存空间寻址时，使用的是32位地址空间(4个字节)，也就是用4个字节就能存储一个内存单元的地址。而指针变量中的值存储的就是地址，所以需要4个字节的空间来存储一个指针变量的值。</p>
<p>示例：</p>
<pre class="highlight"><code class="">int a = 20;
int *pa;
pa = &amp;a;
printf("value = %d \n", *pa);
</code></pre>
<p>在内存中的存储模型如下：</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
<p>对于指针变量pa来说，首先它是一个变量，因此在内存中需要有一个空间来存储这个变量，这个空间的地址就是0x11223348；</p>
<p>其次，这个内存空间中存储的内容是变量a的地址，而a的地址为0x11223344，所以指针变量pa的地址空间中，就存储了0x11223344这个值。</p>
<p>这里对两个操作符&amp;和*进行说明：</p>
<blockquote>
<p>&amp;：取地址操作符，用来获取一个变量的地址。上面代码中&amp;a就是用来获取变量a在内存中的存储地址，也就是0x11223344。</p>
<p>*：这个操作符用在2个场景中：定义一个指针的时候，获取一个指针所指向的变量值的时候。</p>
<blockquote>
<ol>
<li>int <em>pa; 这个语句中的</em>表示定义的变量pa是一个指针，前面的int表示pa这个指针指向的是一个int类型的变量。不过此时我们没有给pa进行赋值，也就是说此刻pa对应的存储单元中的4个字节里的值是没有初始化的，可能是0x00000000，也可能是其他任意的数字，不确定；</li>
<li>printf语句中的*表示获取pa指向的那个int类型变量的值，学名叫解引用，我们只要记住是获取指向的变量的值就可以了。</li>
</ol>
</blockquote>
</blockquote>
<h4 id="5-操作指针变量"><a class="markdownIt-Anchor" href="#5-操作指针变量"></a> 5. 操作指针变量</h4>
<p>对指针变量的操作包括3个方面：</p>
<blockquote>
<ol>
<li>操作指针变量自身的值；</li>
<li>获取指针变量所指向的数据;</li>
<li>以什么样数据类型来使用/解释指针变量所指向的内容。</li>
</ol>
</blockquote>
<h6 id="51-指针变量自身的值"><a class="markdownIt-Anchor" href="#51-指针变量自身的值"></a> 5.1 指针变量自身的值</h6>
<p><code>int a = 20;</code>这个语句是定义变量a，在随后的代码中，只要写下a就表示要操作变量a中存储的值，操作有两种：读和写。</p>
<blockquote>
<p><code>printf("a = %d \n", a);</code> 这个语句就是要读取变量a中的值，当然是20；<br>
<code>a = 100;</code>这个语句就是要把一个数值100写入到变量a中。</p>
</blockquote>
<p>同样的道理，<code>int *pa;</code>语句是用来定义指针变量pa，在随后的代码中，只要写下pa就表示要操作变量pa中的值：</p>
<blockquote>
<p><code>printf("pa = %d \n", pa);</code> 这个语句就是要读取指针变量pa中的值，当然是0x11223344；<br>
<code>pa = &amp;a;</code>这个语句就是要把新的值写入到指针变量pa中。再次强调一下，指针变量中存储的是地址，如果我们可以提前知道变量a的地址是 0x11223344，那么我们也可以这样来赋值:pa = 0x11223344;</p>
</blockquote>
<p>思考一下，<em>如果执行这个语句<code>printf("&amp;pa =0x%x \n", &amp;pa);</code>，打印结果会是什么？</em></p>
<p>上面已经说过，操作符&amp;是用来取地址的，那么&amp;pa就表示获取指针变量pa的地址，上面的内存模型中显示指针变量pa是存储在0x11223348这个地址中的，因此打印结果就是：<code>&amp;pa = 0x11223348</code>。</p>
<h6 id="52-获取指针变量所指向的数据"><a class="markdownIt-Anchor" href="#52-获取指针变量所指向的数据"></a> 5.2 获取指针变量所指向的数据</h6>
<p>指针变量所指向的数据类型是在定义的时候就明确的，也就是说指针pa指向的数据类型就是int型，因此在执行<code>printf("value = %d \n", *pa);</code>语句时，首先知道pa是一个指针，其中存储了一个地址(0x11223344)，然后通过操作符*来获取这个地址(0x11223344)对应的那个存储空间中的值；又因为在定义pa时，已经指定了它指向的值是一个int型，所以我们就知道了地址0x11223344中存储的就是一个int类型的数据。</p>
<h6 id="53-以什么样的数据类型来使用解释指针变量所指向的内容"><a class="markdownIt-Anchor" href="#53-以什么样的数据类型来使用解释指针变量所指向的内容"></a> 5.3 以什么样的数据类型来使用/解释指针变量所指向的内容</h6>
<p>如下代码：</p>
<pre class="highlight"><code class="">int a = 30000;
int *pa = &amp;a;
printf("value = %d \n", *pa);
</code></pre>
<p>根据以上的描述，我们知道printf的打印结果会是<code>value = 30000</code>，十进制的30000转成十六进制是0x00007530，内存模型如下：</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
<p>现在我们做这样一个测试：</p>
<pre class="highlight"><code class="">char *pc = 0x11223344;
printf("value = %d \n", *pc);
</code></pre>
<p>指针变量pc在定义的时候指明：它指向的数据类型是char型，pc变量中存储的地址是0x11223344。当使用*pc获取指向的数据时，将会按照char型格式来读取0x11223344地址处的数据，因此将会打印<code>value = 0</code>(在计算机中，ASCII码是用等价的数字来存储的)。</p>
<p>这个例子中说明了一个重要的概念：在内存中一切都是数字，如何来操作(解释)一个内存地址中的数据，完全是由我们的代码来告诉编译器的。刚才这个例子中，虽然0x11223344这个地址开始的4个字节的空间中，存储的是整型变量a的值，但是我们让pc指针按照char型数据来使用/解释这个地址处的内容，这是完全合法的。</p>
<p>以上内容，就是指针最根本的心法了。把这个心法整明白了，剩下的就是多见识、多练习的问题了。</p>
<h2 id="三-指针的几个相关概念"><a class="markdownIt-Anchor" href="#三-指针的几个相关概念"></a> <strong>三、指针的几个相关概念</strong></h2>
<h4 id="1-const属性"><a class="markdownIt-Anchor" href="#1-const属性"></a> 1. const属性</h4>
<p>const标识符用来表示一个对象的不可变的性质，例如定义：</p>
<pre class="highlight"><code class="">const int b = 20;
</code></pre>
<p>在后面的代码中就不能改变变量b的值了，b中的值永远是20。同样的，如果用const来修饰一个指针变量：</p>
<pre class="highlight"><code class="">int a = 20;
int b = 20;
int * const p = &amp;a;
</code></pre>
<p>内存模型如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/WC13ibsIvG3Z1bQiaSzo5N6GgZ7jYQ7V5o2JibfST9ZIhKBOj0vqEr8IePicK2Bpwicwp1Ir80VejPWhqaR6oXicgqeA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<p>这里的const用来修饰指针变量p，根据const的性质可以得出结论：p在定义为变量a的地址之后，就固定了，不能再被改变了，也就是说指针变量pa中就只能存储变量a的地址0x11223344。如果在后面的代码中写<code>p = &amp;b;</code>，编译时就会报错，因为p是不可改变的，不能再被设置为变量b的地址。</p>
<p>但是，指针变量p所指向的那个变量a的值是可以改变的，即：<code>*p = 21;</code>这个语句是合法的，因为指针p的值没有改变(仍然是变量c的地址0x11223344)，改变的是变量c中存储的值。</p>
<p>与下面的代码区分一下：</p>
<pre class="highlight"><code class="">int a = 20;
int b = 20;
const int *p = &amp;a;
p = &amp;b;
</code></pre>
<p>这里的const没有放在p的旁边，而是放在了类型int的旁边，这就说明const符号不是用来修饰p的，而是用来修饰p所指向的那个变量的。所以，如果我们写<code>p = &amp;b;</code>把变量b的地址赋值给指针p，就是合法的，因为p的值可以被改变。</p>
<p>但是这个语句<code>*p = 21</code>就是非法了，因为定义语句中的const就限制了通过指针p获取的数据，不能被改变，只能被用来读取。这个性质常常被用在函数参数上，例如下面的代码，用来计算一块数据的CRC校验，这个函数只需要读取原始数据，不需要(也不可以)改变原始数据，因此就需要在形参指针上使用const修饰符：</p>
<pre class="highlight"><code class="">short int getDataCRC(const char *pData, int len)
{
    short int crc = 0x0000;
    // 计算CRC
    return crc;
}
</code></pre>
<h4 id="2-void型指针"><a class="markdownIt-Anchor" href="#2-void型指针"></a> 2. void型指针</h4>
<p>关键字void并不是一个真正的数据类型，它体现的是一种抽象，指明不是任何一种类型，一般有2种使用场景：</p>
<blockquote>
<ol>
<li>函数的返回值和形参;</li>
<li>定义指针时不明确规定所指数据的类型，也就意味着可以指向任意类型。</li>
</ol>
</blockquote>
<p>指针变量也是一种变量，变量之间可以相互赋值，那么指针变量之间也可以相互赋值，例如：</p>
<pre class="highlight"><code class="">int a = 20;
int b = a;
int *p1 = &amp;a;
int *p2 = p1;
</code></pre>
<p>变量a赋值给变量b，指针p1赋值给指针p2，注意到它们的类型必须是相同的：a和b都是int型，p1和p2都是指向int型，所以可以相互赋值。那么如果数据类型不同呢？必须进行强制类型转换。例如：</p>
<pre class="highlight"><code class="">int a = 20;
int *p1 = &amp;a;
char *p2 = (char *)p1;
</code></pre>
<p>内存模型如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/WC13ibsIvG3Z1bQiaSzo5N6GgZ7jYQ7V5o9BibyfJmUEXJeGmoj1ibbh6oFUBBbBic9zqMicRNH2RWM8EAWwrVZ0A57Q/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<p>p1指针指向的是int型数据，现在想把它的值(0x11223344)赋值给p2，但是由于在定义p2指针时规定它指向的数据类型是char型，因此需要把指针p1进行强制类型转换，也就是把地址0x11223344处的数据按照char型数据来看待，然后才可以赋值给p2指针。</p>
<p>如果我们使用<code>void *p2</code>来定义p2指针，那么在赋值时就不需要进行强制类型转换了，例如：</p>
<pre class="highlight"><code class="">int a = 20;
int *p1 = &amp;a;
void *p2 = p1;
</code></pre>
<p>指针p2是void<em>型，意味着可以把任意类型的指针赋值给p2，但是不能反过来操作，也就是不能把void</em>型指针直接赋值给其他确定类型的指针，而必须要强制转换成被赋值指针所指向的数据类型，如下代码，必须把p2指针强制转换成int*型之后，再赋值给p3指针：</p>
<pre class="highlight"><code class="">int a = 20;
int *p1 = &amp;a;
void *p2 = p1;
int *p3 = (int *)p2;
</code></pre>
<p>我们来看一个系统函数：</p>
<pre class="highlight"><code class="">void* memcpy(void* dest, const void* src, size_t len);
</code></pre>
<p>第一个参数类型是void*，这正体现了系统对内存操作的真正意义：它并不关心用户传来的指针具体指向什么数据类型，只是把数据挨个存储到这个地址对应的空间中。</p>
<p>第二个参数同样如此，此外还添加了const修饰符，这样就说明了memcpy函数只会从src指针处读取数据，而不会修改数据。</p>
<h4 id="3-空指针和野指针"><a class="markdownIt-Anchor" href="#3-空指针和野指针"></a> 3. 空指针和野指针</h4>
<p>一个指针必须指向一个有意义的地址之后，才可以对指针进行操作。如果指针中存储的地址值是一个随机值，或者是一个已经失效的值，此时操作指针就非常危险了，一般把这样的指针称作野指针，C代码中很多指针相关的bug就来源于此。</p>
<h6 id="31-空指针不指向任何东西的指针"><a class="markdownIt-Anchor" href="#31-空指针不指向任何东西的指针"></a> 3.1 空指针：不指向任何东西的指针</h6>
<p>在定义一个指针变量之后，如果没有赋值，那么这个指针变量中存储的就是一个随机值，有可能指向内存中的任何一个地址空间，此时万万不可以对这个指针进行写操作，因为它有可能指向内存中的代码段区域、也可能指向内存中操作系统所在的区域。</p>
<p>一般会将一个指针变量赋值为NULL来表示一个空指针，而C语言中，NULL实质是 ((void*)0) ， 在C++中，NULL实质是0。在标准库头文件stdlib.h中，有如下定义：</p>
<pre class="highlight"><code class="">#ifdef __cplusplus
     #define NULL    0
#else    
     #define NULL    ((void *)0)
#endif
</code></pre>
<h6 id="32-野指针地址已经失效的指针"><a class="markdownIt-Anchor" href="#32-野指针地址已经失效的指针"></a> 3.2 野指针：地址已经失效的指针</h6>
<p>我们都知道，函数中的局部变量存储在栈区，通过malloc申请的内存空间位于堆区，如下代码：</p>
<pre class="highlight"><code class="">int *p = (int *)malloc(4);
*p = 20;
</code></pre>
<p>内存模型为：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/WC13ibsIvG3Z1bQiaSzo5N6GgZ7jYQ7V5om6BPmn4V4teedD89ufLvP9he344rE9A54GxYEHge534v3H5ocwdokQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<p>在堆区申请了4个字节的空间，然后强制类型转换为int<em>型之后，赋值给指针变量p，然后通过</em>p设置这个地址中的值为14，这是合法的。如果在释放了p指针指向的空间之后，再使用*p来操作这段地址，那就是非常危险了，因为这个地址空间可能已经被操作系统分配给其他代码使用，如果对这个地址里的数据强行操作，程序立刻崩溃的话，将会是我们最大的幸运！</p>
<pre class="highlight"><code class="">int *p = (int *)malloc(4);
*p = 20;
free(p);
// 在free之后就不可以再操作p指针中的数据了。
p = NULL;  // 最好加上这一句。
</code></pre>
<h2 id="四-指向不同数据类型的指针"><a class="markdownIt-Anchor" href="#四-指向不同数据类型的指针"></a> <strong>四、指向不同数据类型的指针</strong></h2>
<h4 id="1-数值型指针"><a class="markdownIt-Anchor" href="#1-数值型指针"></a> 1. 数值型指针</h4>
<p>通过上面的介绍，指向数值型变量的指针已经很明白了，需要注意的就是指针所指向的数据类型。</p>
<h4 id="2-字符串指针"><a class="markdownIt-Anchor" href="#2-字符串指针"></a> 2. 字符串指针</h4>
<p>字符串在内存中的表示有2种：</p>
<blockquote>
<ol>
<li>用一个数组来表示，例如：char name1[8] = “zhangsan”;</li>
<li>用一个char *指针来表示，例如：char *name2 = “zhangsan”;</li>
</ol>
</blockquote>
<p>name1在内存中占据8个字节，其中存储了8个字符的ASCII码值；name2在内存中占据9个字节，因为除了存储8个字符的ASCII码值，在最后一个字符’n’的后面还额外存储了一个’\0’，用来标识字符串结束。</p>
<p>对于字符串来说，使用指针来操作是非常方便的，例如：变量字符串name2:</p>
<pre class="highlight"><code class="">char *name2 = "zhangsan";
char *p = name2;
while (*p != '\0')
{
    printf("%c ", *p);
    p = p + 1;
}
</code></pre>
<p>在while的判断条件中，检查p指针指向的字符是否为结束符’\0’。在循环体重，打印出当前指向的字符之后，对指针比那里进行自增操作，因为指针p所指向的数据类型是char，每个char在内存中占据一个字节，因此指针p在自增1之后，就指向下一个存储空间。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/WC13ibsIvG3Z1bQiaSzo5N6GgZ7jYQ7V5oUOicK7c2YcDkQkqDLicCk5nYz1WaCBZj3uK8wFX8nkViaufRLKXria9aDQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<p>也可以把循环体中的2条语句写成1条语句：</p>
<pre class="highlight"><code class="">printf("%c ", *p++);
</code></pre>
<p>假如一个指针指向的数据类型为int型，那么执行<code>p = p + 1;</code>之后，指针p中存储的地址值将会增加4，因为一个int型数据在内存中占据4个字节的空间，如下所示：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/WC13ibsIvG3Z1bQiaSzo5N6GgZ7jYQ7V5oejIaMRic2qr9ZO5UHWPH5H3r7ClS9ib7U4QmHOUNaoTpicKvK9mN7gndQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<p>思考一个问题：void*型指针能够递增吗？如下测试代码：</p>
<pre class="highlight"><code class="">int a[3] = {1, 2, 3};
void *p = a;
printf("1: p = 0x%x \n", p);
p = p + 1;
printf("2: p = 0x%x \n", p);
</code></pre>
<p>打印结果如下：</p>
<pre class="highlight"><code class="">1: p = 0x733748c0 
2: p = 0x733748c1
</code></pre>
<p>说明void*型指针在自增时，是按照一个字节的跨度来计算的。</p>
<h4 id="3-指针数组与数组指针"><a class="markdownIt-Anchor" href="#3-指针数组与数组指针"></a> 3. 指针数组与数组指针</h4>
<p>这2个说法经常会混淆，至少我是如此，先看下这2条语句：</p>
<pre class="highlight"><code class="">int *p1[3];   // 指针数组
int (*p2)[3]; // 数组指针
</code></pre>
<h6 id="31-指针数组"><a class="markdownIt-Anchor" href="#31-指针数组"></a> 3.1 指针数组</h6>
<p>第1条语句中：中括号[]的优先级高，因此与p1先结合，表示一个数组，这个数组中有3个元素，这3个元素都是指针，它们指向的是int型数据。可以这样来理解：如果有这个定义<code>char p[3]</code>，很容易理解这是一个有3个char型元素的数组，那么把char换成int*，意味着数组里的元素类型是int*型(指向int型数据的指针)。内存模型如下(注意：三个指针指向的地址并不一定是连续的)：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/WC13ibsIvG3Z1bQiaSzo5N6GgZ7jYQ7V5omnyBnn9sdwAuPFRZDUUcgibCavwg5UsTreDRhnNic7y1oGVNHeXU9Uiag/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<p>如果向指针数组中的元素赋值，需要逐个把变量的地址赋值给指针元素：</p>
<pre class="highlight"><code class="">int a = 1, b = 2, c = 3;
char *p1[3];
p1[0] = &amp;a;
p1[1] = &amp;b;
p1[2] = &amp;c;
</code></pre>
<h6 id="32-数组指针"><a class="markdownIt-Anchor" href="#32-数组指针"></a> 3.2 数组指针</h6>
<p>第2条语句中：小括号让p2与<em>结合，表示p2是一个指针，这个指针指向了一个数组，数组中有3个元素，每一个元素的类型是int型。可以这样来理解：如果有这个定义<code>int p[3]</code>，很容易理解这是一个有3个char型元素的数组，那么把数组名p换成是</em>p2，也就是p2是一个指针，指向了这个数组。内存模型如下(注意：指针指向的地址是一个数组，其中的3个元素是连续放在内存中的)：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/WC13ibsIvG3Z1bQiaSzo5N6GgZ7jYQ7V5oPEJOLicTRKWQltWELvHXa3yGF11wwHNic6D7Flv5CSJibUSxl4KNZy7Xw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<p>在前面我们说到取地址操作符&amp;，用来获得一个变量的地址。凡事都有特殊情况，对于获取地址来说，下面几种情况不需要使用&amp;操作符：</p>
<blockquote>
<ol>
<li>字符串字面量作为右值时，就代表这个字符串在内存中的首地址；</li>
<li>数组名就代表这个数组的地址，也等于这个数组的第一个元素的地址;</li>
<li>函数名就代表这个函数的地址。</li>
</ol>
</blockquote>
<p>因此，对于一下代码，三个printf语句的打印结果是相同的：</p>
<pre class="highlight"><code class="">int a[3] = {1, 2, 3};
int (*p2)[3] = a;
printf("0x%x \n", a);
printf("0x%x \n", &amp;a);
printf("0x%x \n", p2);
</code></pre>
<p>思考一下，如果对这里的p2指针执行<code>p2 = p2 + 1;</code>操作，p2中的值将会增加多少？</p>
<p>答案是12个字节。因为p2指向的是一个数组，这个数组中包含3个元素，每个元素占据4个字节，那么这个数组在内存中一共占据12个字节，因此p2在加1之后，就跳过12个字节。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/WC13ibsIvG3Z1bQiaSzo5N6GgZ7jYQ7V5o6szATiblmgqyIRbBJHCyia7D6DNSkDfRfwy9bFxrb7jibz4d0ZAKbx5vw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<h4 id="4-二维数组和指针"><a class="markdownIt-Anchor" href="#4-二维数组和指针"></a> 4. 二维数组和指针</h4>
<p>一维数组在内存中是连续分布的多个内存单元组成的，而二维数组在内存中也是连续分布的多个内存单元组成的，从内存角度来看，一维数组和二维数组没有本质差别。</p>
<p>和一维数组类似，二维数组的数组名表示二维数组的第一维数组中首元素的首地址，用代码来说明：</p>
<pre class="highlight"><code class="">int a[3][3] = {{1,2,3}, {4,5,6}, {7,8,9}}; // 二维数组
int (*p0)[3] = NULL;   // p0是一个指针，指向一个数组
int (*p1)[3] = NULL;   // p1是一个指针，指向一个数组
int (*p2)[3] = NULL;   // p2是一个指针，指向一个数组
p0 = a[0];
p1 = a[1];
p2 = a[2];
printf("0: %d %d %d \n", *(*p0 + 0), *(*p0 + 1), *(*p0 + 2));
printf("1: %d %d %d \n", *(*p1 + 0), *(*p1 + 1), *(*p1 + 2));
printf("2: %d %d %d \n", *(*p2 + 0), *(*p2 + 1), *(*p2 + 2));
</code></pre>
<p>打印结果是：</p>
<pre class="highlight"><code class="">0: 1 2 3 
1: 4 5 6 
2: 7 8 9
</code></pre>
<p>我们拿第一个printf语句来分析：p0是一个指针，指向一个数组，数组中包含3个元素，每个元素在内存中占据4个字节。现在我们想获取这个数组中的数据，如果直接对p0执行加1操作，那么p0将会跨过12个字节(就等于p1中的值了)，因此需要使用解引用操作符*，把p0转为指向int型的指针，然后再执行加1操作，就可以得到数组中的int型数据了。</p>
<h4 id="5-结构体指针"><a class="markdownIt-Anchor" href="#5-结构体指针"></a> 5. 结构体指针</h4>
<p>C语言中的基本数据类型是预定义的，结构体是用户定义的，在指针的使用上可以进行类比，唯一有区别的就是在结构体指针中，需要使用<code>-&gt;</code>箭头操作符来获取结构体中的成员变量，例如：</p>
<pre class="highlight"><code class="">typedef struct 
{
    int age;
    char name[8];
} Student;

Student s;
s.age = 20;
strcpy(s.name, "lisi");
Student *p = &amp;s;
printf("age = %d, name = %s \n", p-&gt;age, p-&gt;name);
</code></pre>
<p>看起来似乎没有什么技术含量，如果是结构体数组呢？例如：</p>
<pre class="highlight"><code class="">Student s[3];
Student *p = &amp;s;
printf("size of Student = %d \n", sizeof(Student));
printf("1: 0x%x, 0x%x \n", s, p);
p++;
printf("2: 0x%x \n", p);
</code></pre>
<p>打印结果是：</p>
<pre class="highlight"><code class="">size of Student = 12 
1: 0x4c02ac00, 0x4c02ac00 
2: 0x4c02ac0c
</code></pre>
<p>在执行<code>p++</code>操作后，p需要跨过的空间是一个结构体变量在内存中占据的大小(12个字节)，所以此时p就指向了数组中第2个元素的首地址，内存模型如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/WC13ibsIvG3Z1bQiaSzo5N6GgZ7jYQ7V5oIUrWVMylNkAicCCp5DNjIqNDnicscmBXcOjqGia6jTvIcKszic3dryiadgg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<h4 id="6-函数指针"><a class="markdownIt-Anchor" href="#6-函数指针"></a> 6. 函数指针</h4>
<p>每一个函数在经过编译之后，都变成一个包含多条指令的集合，在程序被加载到内存之后，这个指令集合被放在代码区，我们在程序中使用函数名就代表了这个指令集合的开始地址。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/WC13ibsIvG3Z1bQiaSzo5N6GgZ7jYQ7V5oZVqkqUzdjYgByD7Gd0LRZIw4zaCBnHK2jHTic1PbV1ia1zJdP8uEJq6Q/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<p>函数指针，本质上仍然是一个指针，只不过这个指针变量中存储的是一个函数的地址。函数最重要特性是什么？可以被调用！因此，当定义了一个函数指针并把一个函数地址赋值给这个指针时，就可以通过这个函数指针来调用函数。</p>
<p>如下示例代码：</p>
<pre class="highlight"><code class="">int add(int x,int y)
{
    return x+y;
}

int main()
{
    int a = 1, b = 2;
    int (*p)(int, int);
    p = add;
    printf("%d + %d = %d\n", a, b, p(a, b));
}
</code></pre>
<p>前文已经说过，函数的名字就代表函数的地址，所以函数名add就代表了这个加法函数在内存中的地址。<code>int (*p)(int, int);</code>这条语句就是用来定义一个函数指针，它指向一个函数，这个函数必须符合下面这2点(学名叫：函数签名)：</p>
<blockquote>
<ol>
<li>有2个int型的参数;</li>
<li>有一个int型的返回值。</li>
</ol>
</blockquote>
<p>代码中的add函数正好满足这个要求，因此，可以把add赋值给函数指针p，此时p就指向了内存中这个函数存储的地址，后面就可以用函数指针p来调用这个函数了。</p>
<p>在示例代码中，函数指针p是直接定义的，那如果想定义2个函数指针，难道需要像下面这样定义吗？</p>
<pre class="highlight"><code class="">int (*p)(int, int);
int (*p2)(int, int);
</code></pre>
<p>这里的参数比较简单，如果函数很复杂，这样的定义方式岂不是要烦死？可以用typedef关键字来定义一个函数指针类型：</p>
<pre class="highlight"><code class="">typedef int (*pFunc)(int, int);
</code></pre>
<p>然后用这样的方式<code>pFunc p1, p2;</code>来定义多个函数指针就方便多了。注意：只能把与函数指针类型具有相同签名的函数赋值给p1和p2，也就是参数的个数、类型要相同，返回值也要相同。</p>
<p>注意：这里有几个小细节稍微了解一下：</p>
<blockquote>
<ol>
<li>在赋值函数指针时，使用p = &amp;a;也是可以的；</li>
<li>使用函数指针调用时，使用(*p)(a, b);也是可以的。</li>
</ol>
</blockquote>
<p>这里没有什么特殊的原理需要讲解，最终都是编译器帮我们处理了这里的细节，直接记住即可。</p>
<p>函数指针整明白之后，再和数组结合在一起：函数指针数组。示例代码如下：</p>
<pre class="highlight"><code class="">int add(int a, int b) { return a + b; }
int sub(int a, int b) { return a - b; }
int mul(int a, int b) { return a * b; }
int divide(int a, int b) { return a / b; }

int main()
{
    int a = 4, b = 2;
    int (*p[4])(int, int);
    p[0] = add;
    p[1] = sub;
    p[2] = mul;
    p[3] = divide;
    printf("%d + %d = %d \n", a, b, p[0](a, b));
    printf("%d - %d = %d \n", a, b, p[1](a, b));
    printf("%d * %d = %d \n", a, b, p[2](a, b));
    printf("%d / %d = %d \n", a, b, p[3](a, b));
}
</code></pre>
<p>这条语句不太好理解:<code>int (*p[4])(int, int);</code>，先分析中间部分，标识符p与中括号[]结合(优先级高)，所以p是一个数组，数组中有4个元素；然后剩下的内容表示一个函数指针，那么就说明数组中的元素类型是函数指针，也就是其他函数的地址，内存模型如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/WC13ibsIvG3Z1bQiaSzo5N6GgZ7jYQ7V5oG5UFEzUxzS3bqQ3acUWyRRPaq76c6ex3xOReMoZLv5kV7Aia1YdudIw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<p>如果还是难以理解，那就回到指针的本质概念上：指针就是一个地址！这个地址中存储的内容是什么根本不重要，重要的是你告诉计算机这个内容是什么。如果你告诉它：这个地址里存放的内容是一个函数，那么计算机就去调用这个函数。那么你是如何告诉计算机的呢，就是在定义指针变量的时候，仅此而已！</p>
<h2 id="五-总结"><a class="markdownIt-Anchor" href="#五-总结"></a> <strong>五、总结</strong></h2>
<p>我已经把自己知道的所有指针相关的概念、语法、使用场景都作了讲解，就像一个小酒馆的掌柜，把自己的美酒佳肴都呈现给你，但愿你已经酒足饭饱！</p>
<p>如果以上的内容太多，一时无法消化，那么下面的这两句话就作为饭后甜点为您奉上，在以后的编程中，如果遇到指针相关的困惑，就想一想这两句话，也许能让你茅塞顿开。</p>
<blockquote>
<ol>
<li>指针就是地址，地址就是指针。</li>
<li>指针就是指向内存中的一块空间，至于如何来解释/操作这块空间，由这个指针的类型来决定。</li>
</ol>
</blockquote>
<p>另外还有一点嘱咐，那就是学习任何一门编程语言，一定要弄清楚内存模型，内存模型，内存模型！</p>
<p>祝您好运！</p>
</article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="addthis_inline_share_toolbox"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=null" async="async"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/04/18/21%E5%B9%B44%E6%9C%88%E7%AC%AC3%E7%AF%87%E5%91%A8%E5%BF%97/"><img class="prev-cover" src="https://images.pexels.com/photos/167699/pexels-photo-167699.jpeg?auto=compress&amp;cs=tinysrgb&amp;dpr=2&amp;h=650&amp;w=940" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">21年4月第3篇周志</div></div></a></div><div class="next-post pull-right"><a href="/2021/04/04/21%E5%B9%B44%E6%9C%88%E7%AC%AC1%E7%AF%87%E5%91%A8%E5%BF%97/"><img class="next-cover" src="https://images.pexels.com/photos/208216/pexels-photo-208216.jpeg?auto=compress&amp;cs=tinysrgb&amp;dpr=2&amp;h=650&amp;w=940" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">21年4月第1篇周志</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside_content" id="aside_content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/Lion_El'Jonson.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">Messier</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div></div><a class="button--animated" id="card-info-btn" href="https://bithoxer.github.io/atom.xml"><i class="fas fa-rss"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/bithoxer" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://bithoxer.github.io/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a><a class="social-icon" href="https://weibo.com/bithoxer" target="_blank" title="Weibo"><i class="fab fa-weibo"></i></a></div></div></div><div class="card-widget card-announcement"><div class="card-content"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">上网不涉密，涉密不上网。</div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%81%A5%E6%84%9F%E4%BC%81%E4%B8%9A"><span class="toc-number">1.</span> <span class="toc-text"> 遥感企业</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8C%87%E9%92%88"><span class="toc-number">2.</span> <span class="toc-text"> 指针</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#c%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88-%E4%BB%8E%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%88%B0%E8%8A%B1%E5%BC%8F%E6%8A%80%E5%B7%A7%E7%94%A8%E5%9B%BE%E6%96%87%E5%92%8C%E4%BB%A3%E7%A0%81%E5%B8%AE%E4%BD%A0%E8%AE%B2%E8%A7%A3%E9%80%8F%E5%BD%BB"><span class="toc-number">2.1.</span> <span class="toc-text"> C语言指针-从底层原理到花式技巧，用图文和代码帮你讲解透彻</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E5%89%8D%E8%A8%80"><span class="toc-number">2.2.</span> <span class="toc-text"> 一、前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E5%8F%98%E9%87%8F%E4%B8%8E%E6%8C%87%E9%92%88%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">2.3.</span> <span class="toc-text"> 二、变量与指针的本质</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80"><span class="toc-number">2.3.0.1.</span> <span class="toc-text"> 1. 内存地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-32%E4%BD%8D%E4%B8%8E64%E4%BD%8D%E7%B3%BB%E7%BB%9F"><span class="toc-number">2.3.0.2.</span> <span class="toc-text"> 2. 32位与64位系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%8F%98%E9%87%8F"><span class="toc-number">2.3.0.3.</span> <span class="toc-text"> 3. 变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F"><span class="toc-number">2.3.0.4.</span> <span class="toc-text"> 4. 指针变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%93%8D%E4%BD%9C%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F"><span class="toc-number">2.3.0.5.</span> <span class="toc-text"> 5. 操作指针变量</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#51-%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E8%87%AA%E8%BA%AB%E7%9A%84%E5%80%BC"><span class="toc-number">2.3.0.5.0.1.</span> <span class="toc-text"> 5.1 指针变量自身的值</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#52-%E8%8E%B7%E5%8F%96%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E6%89%80%E6%8C%87%E5%90%91%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-number">2.3.0.5.0.2.</span> <span class="toc-text"> 5.2 获取指针变量所指向的数据</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#53-%E4%BB%A5%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9D%A5%E4%BD%BF%E7%94%A8%E8%A7%A3%E9%87%8A%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E6%89%80%E6%8C%87%E5%90%91%E7%9A%84%E5%86%85%E5%AE%B9"><span class="toc-number">2.3.0.5.0.3.</span> <span class="toc-text"> 5.3 以什么样的数据类型来使用&#x2F;解释指针变量所指向的内容</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E6%8C%87%E9%92%88%E7%9A%84%E5%87%A0%E4%B8%AA%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-number">2.4.</span> <span class="toc-text"> 三、指针的几个相关概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-const%E5%B1%9E%E6%80%A7"><span class="toc-number">2.4.0.1.</span> <span class="toc-text"> 1. const属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-void%E5%9E%8B%E6%8C%87%E9%92%88"><span class="toc-number">2.4.0.2.</span> <span class="toc-text"> 2. void型指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%A9%BA%E6%8C%87%E9%92%88%E5%92%8C%E9%87%8E%E6%8C%87%E9%92%88"><span class="toc-number">2.4.0.3.</span> <span class="toc-text"> 3. 空指针和野指针</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#31-%E7%A9%BA%E6%8C%87%E9%92%88%E4%B8%8D%E6%8C%87%E5%90%91%E4%BB%BB%E4%BD%95%E4%B8%9C%E8%A5%BF%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">2.4.0.3.0.1.</span> <span class="toc-text"> 3.1 空指针：不指向任何东西的指针</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#32-%E9%87%8E%E6%8C%87%E9%92%88%E5%9C%B0%E5%9D%80%E5%B7%B2%E7%BB%8F%E5%A4%B1%E6%95%88%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">2.4.0.3.0.2.</span> <span class="toc-text"> 3.2 野指针：地址已经失效的指针</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-%E6%8C%87%E5%90%91%E4%B8%8D%E5%90%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">2.5.</span> <span class="toc-text"> 四、指向不同数据类型的指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%95%B0%E5%80%BC%E5%9E%8B%E6%8C%87%E9%92%88"><span class="toc-number">2.5.0.1.</span> <span class="toc-text"> 1. 数值型指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8C%87%E9%92%88"><span class="toc-number">2.5.0.2.</span> <span class="toc-text"> 2. 字符串指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84%E4%B8%8E%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88"><span class="toc-number">2.5.0.3.</span> <span class="toc-text"> 3. 指针数组与数组指针</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#31-%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84"><span class="toc-number">2.5.0.3.0.1.</span> <span class="toc-text"> 3.1 指针数组</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#32-%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88"><span class="toc-number">2.5.0.3.0.2.</span> <span class="toc-text"> 3.2 数组指针</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88"><span class="toc-number">2.5.0.4.</span> <span class="toc-text"> 4. 二维数组和指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E7%BB%93%E6%9E%84%E4%BD%93%E6%8C%87%E9%92%88"><span class="toc-number">2.5.0.5.</span> <span class="toc-text"> 5. 结构体指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">2.5.0.6.</span> <span class="toc-text"> 6. 函数指针</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94-%E6%80%BB%E7%BB%93"><span class="toc-number">2.6.</span> <span class="toc-text"> 五、总结</span></a></li></ol></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/06/01/21%E5%B9%B46%E6%9C%88%E7%AC%AC1%E7%AF%87%E5%91%A8%E5%BF%97/" title="21年6月第1篇周志"><img src="https://images.pexels.com/photos/6678638/pexels-photo-6678638.jpeg?auto=compress&amp;cs=tinysrgb&amp;dpr=2&amp;h=650&amp;w=940" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="21年6月第1篇周志"/></a><div class="content"><a class="title" href="/2021/06/01/21%E5%B9%B46%E6%9C%88%E7%AC%AC1%E7%AF%87%E5%91%A8%E5%BF%97/" title="21年6月第1篇周志">21年6月第1篇周志</a><time datetime="2021-05-31T18:02:44.000Z" title="发表于 2021-06-01 02:02:44">2021-06-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/05/22/21%E5%B9%B45%E6%9C%88%E7%AC%AC4%E7%AF%87%E5%91%A8%E5%BF%97/" title="21年5月第4篇周志"><img src="https://images.pexels.com/photos/5628141/pexels-photo-5628141.jpeg?auto=compress&amp;cs=tinysrgb&amp;dpr=2&amp;h=650&amp;w=940" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="21年5月第4篇周志"/></a><div class="content"><a class="title" href="/2021/05/22/21%E5%B9%B45%E6%9C%88%E7%AC%AC4%E7%AF%87%E5%91%A8%E5%BF%97/" title="21年5月第4篇周志">21年5月第4篇周志</a><time datetime="2021-05-21T18:35:09.000Z" title="发表于 2021-05-22 02:35:09">2021-05-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/05/18/21%E5%B9%B45%E6%9C%88%E7%AC%AC3%E7%AF%87%E5%91%A8%E5%BF%97/" title="21年5月第3篇周志"><img src="https://images.pexels.com/photos/5792849/pexels-photo-5792849.jpeg?cs=srgb&amp;dl=pexels-laker-5792849.jpg&amp;fm=jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="21年5月第3篇周志"/></a><div class="content"><a class="title" href="/2021/05/18/21%E5%B9%B45%E6%9C%88%E7%AC%AC3%E7%AF%87%E5%91%A8%E5%BF%97/" title="21年5月第3篇周志">21年5月第3篇周志</a><time datetime="2021-05-18T09:24:37.000Z" title="发表于 2021-05-18 17:24:37">2021-05-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/05/09/21%E5%B9%B45%E6%9C%88%E7%AC%AC2%E7%AF%87%E5%91%A8%E5%BF%97/" title="21年5月第2篇周志"><img src="https://images.pexels.com/photos/1089438/pexels-photo-1089438.jpeg?cs=srgb&amp;dl=pexels-markus-spiske-1089438.jpg&amp;fm=jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="21年5月第2篇周志"/></a><div class="content"><a class="title" href="/2021/05/09/21%E5%B9%B45%E6%9C%88%E7%AC%AC2%E7%AF%87%E5%91%A8%E5%BF%97/" title="21年5月第2篇周志">21年5月第2篇周志</a><time datetime="2021-05-09T09:07:04.000Z" title="发表于 2021-05-09 17:07:04">2021-05-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/05/03/21%E5%B9%B45%E6%9C%88%E7%AC%AC1%E7%AF%87%E5%91%A8%E5%BF%97/" title="21年5月第1篇周志"><img src="https://images.pexels.com/photos/1274260/pexels-photo-1274260.jpeg?auto=compress&amp;cs=tinysrgb&amp;dpr=2&amp;h=650&amp;w=940" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="21年5月第1篇周志"/></a><div class="content"><a class="title" href="/2021/05/03/21%E5%B9%B45%E6%9C%88%E7%AC%AC1%E7%AF%87%E5%91%A8%E5%BF%97/" title="21年5月第1篇周志">21年5月第1篇周志</a><time datetime="2021-05-03T06:18:42.000Z" title="发表于 2021-05-03 14:18:42">2021-05-03</time></div></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(https://raw.githubusercontent.com/bithoxer/imagestor/main/20210411235929.jpg)"><div id="footer-wrap"><div class="footer_custom_text">Thy will be done.</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.spacingElementById('content-inner')
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.spacingElementById('content-inner')
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> {preloader.endLoading()})</script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', '', 'katex-wrap')
  })
})()</script><script>(()=>{
  const $countDom = document.getElementById('twikoo-count')
  const init = () => {
    twikoo.init({
      envId: 'bitblogcomment-6g6nmkrne94011f8',
      el: '#twikoo-wrap'
    })
  }

  const getCount = () => {
    twikoo.getCommentsCount({
      envId: 'bitblogcomment-6g6nmkrne94011f8',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      $countDom.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const loadTwikoo = (bool = false) => {
    if (typeof twikoo === 'object') {
      init()
      bool && $countDom && setTimeout(getCount,0)
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(()=> {
        init()
        bool && $countDom && setTimeout(getCount,0)
      })
    }
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo(true)
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config_change',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  if (typeof gtag === 'function') {
    gtag('config', '', {'page_path': window.location.pathname});
  }

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})


document.addEventListener('pjax:send', function () {
  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})</script><script>(function(){
  const bp = document.createElement('script');
  const curProtocol = window.location.protocol.split(':')[0];
  if (curProtocol === 'https') {
    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else{
    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
  bp.dataset.pjax = ''
  const s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
})()</script></div></body></html>